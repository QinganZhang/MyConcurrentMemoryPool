##### 定长内存池部分：
- 对于定长内存池，它只能分配某种类型或某个大小的内存块，这个类型或大小也是提前设定好的。
- 项目结构就是定长内存池先申请大块内存，然后分成小块的内存块，并创建对象。这些小对象析构之后，使用一个链表将这些小对象对应的内存回收而来并进行管理。如果需要再分配小对象时，优先分配链表上管理的这些小块内存，链表为空时才继续从大块内存中分配。
- 之前的项目都是只支持win32，这里进行了跨平台拓展，拓展到linux平台（win64应该也可以），背后的修改主要是对于linux平台，使用mmap申请内存，并使用链表，记录每次申请的大块内存的地址和大小，在析构定长内存池时使用munmap释放申请的大块内存
    > 知识点：mmap
        > - https://blog.csdn.net/qq_41687938/article/details/119901916
        > - 程序员的自我修养


##### thread cache部分：
- 首先，每个线程独享自己的thread cache，即每个线程申请内存时，首先从自己的thread cache中申请，因此申请小块内存时可以做到无锁
    > 知识点：线程局部存储
        > - https://blog.csdn.net/xiaokaige198747/article/details/80518455
- 其次，thread cache的内部结构类似于一个数组链表（邻接表）的结构，数组中每个元素即为特定大小内存块的链表。因为thread cache是线程独享的，因此数组尺寸不宜过大，同时又要保证可以申请1B~256KB大小的内存块，因此需要进行一定的权衡：对于小的内存块，可以采用细粒度的桶（比如桶可以分别为：8B，16B，24B，...，每相差8B就有一个桶），对于大的内存块，可以采用较粗粒度的桶（比如桶可以分别为：8KB，9KB，10KB，...，，每相差1KB才有一个桶），这样不仅减小了数组的大小，同时也可以支持分配不同大小的内存块


使用cmake进行构建，生成测试的可执行文件，并生成静态链接库和动态链接库，同时`make install`可以在构建时自定义安装路径进行安装（也可以不安装）
如果别的文件想使用MyConcurrentMemoryPool，可以将include目录下的头文件和src目录下的源码拷贝过去源码编译，也可以使用生成好的链接库（注意静态链接库和动态链接库不要放在一个文件中，否则会出现多重定义的错误）